#include <ros/ros.h>
#include <ros/node_handle.h>
#include <cstdlib>
#include <robot_mask/GetMask.h>
#include <opencv/cv.h>
#include <opencv2/highgui/highgui.hpp>
#include <boost/thread.hpp>
#include <message_filters/time_synchronizer.h>
#include <sensor_msgs/Image.h>
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <sensor_msgs/CameraInfo.h>
#include <cv_bridge/CvBridge.h>

using namespace sensor_msgs;
using namespace message_filters;

class LatestMatchingTFMessage
{
public:
  ros::ServiceClient client ;
  robot_mask::GetMask srv;
  tf::tfMessageConstPtr tf_state , last_matching_tf;
  cv::Mat mask ,original_image;
  message_filters::Subscriber<Image> image_sub;
  message_filters::Subscriber<CameraInfo> cam_sub;
  message_filters::Subscriber<tf::tfMessage> tf_sub;
  sensor_msgs::CvBridge bridge_;

  LatestMatchingTFMessage(ros::NodeHandle &nh, const std::string &source_frame)
    : source_frame_(source_frame),
      nh_ (nh),
      valid_(false)
      //sync(image_sub, tf_sub, 10)
  {
    //create a thread
    spin_thread_ = boost::thread (boost::bind (&ros::spin));
    //subscribe the tfMessage
    tf_sub.subscribe(nh_, "/tf", 1);
    image_sub.subscribe(nh_, "image", 1);
    //TimeSynchronizer <Image, tf::tfMessage> sync(image_sub, tf_sub, 10);
    //sync.registerCallback (boost::bind (&LatestMatchingTFMessage::callback, this, _1, _2));
    //create a new window named Mask for see the cv::Mat img
    cv::namedWindow("Mask",CV_WINDOW_AUTOSIZE);
    //instantiate an autogenerated service class, and assign values into its request member.
    client = nh.serviceClient<robot_mask::GetMask>("/robot_mask/get_mask");
    srv.request.width = 640 ;
    srv.request.height = 480 ;
    srv.request.fovy = 45 ;
    srv.request.camera_frame = "narrow_stereo_optical_frame";
    //create the cv::Mat to copy the values from the mask[] into it
    mask.create(srv.request.height ,srv.request.width,CV_8UC1);
  }

  /////////////////////////////////////////////////
  // bool getTF(tf::tfMessageConstPtr& ret)
  // {
  //   ros::Rate r(100);
  //   while(!valid_)
  //   {
  //     if (nh_.ok())
  //       r.sleep();
  //     else
  //       return false;
  //   }
  //   ret = last_matching_tf;
  //   return true;
  // }
  /////////////////////////////////////////////////////////
  int spin()
  {
    ros::Rate loop_rate(25);
    while (nh_.ok())
    {
      if(valid_==true)
      {
        srv.request.tf_state = *last_matching_tf;
        ROS_INFO("waiting for service server... ");
        if(!client.waitForExistence (ros::Duration (1)))
        {
          ROS_ERROR("Could not find service.");
          return 1;
        }
        ROS_INFO("found. calling now.");
        // calls the service
        if (client.call(srv))
        {
          //copy the first 640 elements from mask array into first row of cv::Mat and so on..
          for (unsigned int i=0; i < srv.response.mask.size(); i++)
          {
            if (srv.response.mask[i] == 1)
              mask.at<uint8_t>(i/mask.cols, i%mask.cols) = 255;
            else
              mask.at<uint8_t>(i/mask.cols, i%mask.cols) = srv.response.mask[i];
          }
        }
        else
        {
          ROS_ERROR("Failed to call service robot_mask");
          return 1;
        }
        ROS_INFO("after service call");


        //display window on the screen
        cv::imshow("Mask",mask);
        cv::waitKey(10);
        //save the image to Mask.png
        //cv::imwrite("Mask.png",mask);
      }
      valid_=false;
      loop_rate.sleep();
    }
    return 0;
  }

private:
  ros::Subscriber tf_sub_;
  std::string source_frame_;
  ros::NodeHandle nh_;
  bool valid_;
  boost::thread spin_thread_;

  /////////////////////////////////////////////////////////
   void callback(const ImageConstPtr& image_msg ,const tf::tfMessageConstPtr &msg )
  {
    if(msg->transforms[0].header.frame_id == source_frame_)
    {
      last_matching_tf = msg;
      //use cv_bridge to get the original image
      try 
      {
        original_image = bridge_.imgMsgToCv(image_msg, "rgb8");
      }
      catch (sensor_msgs::CvBridgeException& ex) 
      {
        ROS_ERROR("[PointCloudToImageProjector:] Failed to convert image");
        return;
      }

      //original_image = 
      valid_ = true;
    }
  }
};

/////////////////////////////////////////////////////
int main(int argc, char **argv)
{
  //get_mask_client is the name of the node for client and get_mask is for the server
  ros::init(argc, argv, "get_mask_client");
  ros::NodeHandle n;
  LatestMatchingTFMessage tf(n, "/base_footprint");
  tf.spin();
}

