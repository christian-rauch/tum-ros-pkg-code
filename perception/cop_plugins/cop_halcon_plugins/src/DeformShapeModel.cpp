/*
 * Copyright (C) 2009 by Ulrich Friedrich Klank <klank@in.tum.de>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


/*#ifdef DEFORMSHAPE_AVAILABLE*/
#include "DeformShapeModel.h"
#include "XMLTag.h"
#include "Camera.h"
#include "RelPoseHTuple.h"

#include "cpp/HalconCpp.h"
using namespace Halcon;



#define XML_NODE_FILENAME "filename"
#define XML_NODE_XNORM "xnorm"
#define XML_NODE_YNORM "ynorm"

#define XML_ATTRIBUTE_AUTOGENERATED "auto"

using namespace cop;


DeformShapeModel::DeformShapeModel(Class* classref) :
	Descriptor(classref),
	m_bWritten(false),
	m_regionTemp(NULL),
	m_autoLearned(true)
{

	/*
	sig->Get
	create_planar_uncalib_deformable_model();
	*/
}

DeformShapeModel::DeformShapeModel() :
  m_bWritten(false),
  m_regionTemp(NULL),
  m_autoLearned(true)
{

}

void DeformShapeModel::SetData(XMLTag* tag)
{
	Descriptor::SetData(tag),
	m_filename = "";


  if(tag != NULL)
  {
    int i = 0;
    while(tag != NULL)
    {
      XMLTag* xml_filename = tag->GetChild(XML_NODE_FILENAME, i++);
      if(xml_filename != NULL)
      {
          m_filename = xml_filename->GetCDataST();
          if(LoadFromFile(m_filename, xml_filename->GetProperty(XML_PROPERTY_SENSORNAME, "default")))
            m_bWritten = true;

      }
      else
       break;
    }

    m_autoLearned = tag->GetProperty(XML_ATTRIBUTE_AUTOGENERATED, "false").compare("true") == 0 ? true : false;
  }
}

DeformShapeModel::~DeformShapeModel(void)
{
  std::map<std::string, SensorSpecificDeformModel>::const_iterator iter = m_models.begin();
  for( ;iter != m_models.end(); iter++)
  {
    clear_deformable_model((*iter).second.m_handle);
  }
	delete m_regionTemp;
}

bool DeformShapeModel::LoadFromFile(std::string fileName, std::string stSensorID)
{
  Hlong id;
  std::pair<std::string, std::vector< double> > vec_temp;
  try
  {
    Halcon::HTuple tup;
    read_deformable_model(fileName.c_str(), &id);
    get_deformable_model_params (id, "cam_param", &tup);

    vec_temp.first = "RECTHALCONCALIB";
    vec_temp.second.push_back( tup[0].D());
    vec_temp.second.push_back( tup[2].D());
    vec_temp.second.push_back( tup[3].D());
    vec_temp.second.push_back( tup[4].D());
    vec_temp.second.push_back( tup[5].D());
    vec_temp.second.push_back( tup[6].D());
    vec_temp.second.push_back( tup[7].D());
    m_bWritten = true;
  }
  catch(Halcon::HException ex)
  {
    printf("Error reading DeformShapeModel from file: %s\n", fileName.c_str());
    return false;
  }
  m_models[stSensorID].m_handle = id;
  m_models[stSensorID].m_calib = MinimalCalibration(vec_temp);
  return true;
}

void DeformShapeModel::Show(RelPose* pose, Sensor* camin)
{

  if(camin != NULL && camin->IsCamera())
  {
    Camera* cam = (Camera*)camin;
    Hobject xld;
  //get_deformable_model_contours(&xld, m_handle, 1);
    try
    {
      printf("In DeformShapeModel::Show\n");
      HWindow* hwin = cam->GetWindow();
      hwin->SetColor("red");
      hwin->SetLineWidth(3);
      HTuple row, col, pose_ht,HomMat3DToWorld, CamParam = cam->m_calibration.CamParam();
      RelPoseHTuple::GetPose(pose, &pose_ht, cam->m_relPose->m_uniqueID);
      RelPoseHTuple::GetHommat(pose, &HomMat3DToWorld, 1);
      /*TOCHECK why?*/
      /**  The next 4 lines rotate the pose to the training
          pose that is needed to display everything right
          This might be wrong for some pretrained things
      */
      if(m_autoLearned)
      {
        HTuple HomMat3D;
        pose_to_hom_mat3d (pose_ht, &HomMat3D);
        hom_mat3d_rotate_local(HomMat3D, M_PI, "y", &HomMat3D);
        hom_mat3d_to_pose (HomMat3D, &pose_ht);
      }
      long handle;
      if(m_models.find(camin->GetSensorID()) != m_models.end())
      {
        handle = m_models[camin->GetSensorID()].m_handle;
      }
      else if (m_models.find("default") != m_models.end())
      {
        handle = m_models["default"].m_handle;
      }
      else
      {
        return;
      }
      project_3d_point(pose_ht[0],pose_ht[1], pose_ht[2], CamParam, &row, &col);
      disp_cross(hwin->WindowHandle(), row, col, 60, 0.79);

      HTuple ModelRow, ModelCol, ModelPose, hom2d(6), NumberContour, HomMat3D;
      Hobject ModelContours, ContoursAffinTrans, ContoursTrans, FoundContour, ObjectSelected;

      get_deformable_model_contours (&ModelContours, handle, 1);
      get_deformable_model_params (handle, "model_row", &ModelRow);
      get_deformable_model_params (handle, "model_col", &ModelCol);
      get_deformable_model_params (handle, "model_pose", &ModelPose);
      hom2d[0] = 1;hom2d[1] = 0;hom2d[2] = ModelRow;hom2d[3] = 0; hom2d[4] = 1; hom2d[5] = ModelCol;
      affine_trans_contour_xld (ModelContours, &ContoursAffinTrans, hom2d);
      contour_to_world_plane_xld (ContoursAffinTrans, &ContoursTrans, CamParam, ModelPose, "m");
      count_obj (ContoursTrans, &NumberContour);
      pose_to_hom_mat3d (pose_ht, &HomMat3D);
      gen_empty_obj (&FoundContour);
      std::vector<double> x,y,z;
      printf("Creating pcd\n");
      for (int index = 1; index <= NumberContour; index++)
      {
        HTuple X,Y,Z, Xc, Yc, Zc, R, C, Xworld, Yworld, Zworld;
        Hobject ModelWorld;
        select_obj (ContoursTrans, &ObjectSelected, index);
        get_contour_xld (ObjectSelected, &Y, &X);
        Halcon::tuple_gen_const(X.Num(), 0.0, &Z);
        affine_trans_point_3d (HomMat3D, X, Y, Z, &Xc, &Yc, &Zc);
        affine_trans_point_3d (HomMat3DToWorld, X, Y, Z, &Xworld, &Yworld, &Zworld);
        for(int i = 0; i < Xworld.Num(); i++)
        {
          x.push_back(Xworld[i].D());
          y.push_back(Yworld[i].D());
          z.push_back(Zworld[i].D());
        }
        project_3d_point (Xc, Yc, Zc, CamParam, &R, &C);
        gen_contour_polygon_xld (&ModelWorld, R, C);
        concat_obj (FoundContour, ModelWorld, &FoundContour);
      }
      cam->Publish3DData(x,y,z);

      disp_obj(FoundContour, hwin->WindowHandle());

      if(m_regionTemp != NULL)
      {
        hwin->SetDraw("margin");
         disp_obj( *m_regionTemp, hwin->WindowHandle());
         delete m_regionTemp;
         m_regionTemp = NULL;
      }
      hwin->SetLineWidth(1);
    }
    catch(Halcon::HException ex)
    {
      printf("Problems showing DeformShapeModel: %s\n", ex.message);
    }
    catch(const char *text)
    {
      printf("Problems showing DeformShapeModel: %s\n", text);
    }
  }

}


double DeformShapeModel::DefineDeformShapeModel(Image* image, Halcon::Hobject* region, Camera* cam, RelPose* pose)
{
  Halcon::HTuple score;
  m_autoLearned = true;
  try
  {
    Halcon::Hobject imgReduced, *img;
    Halcon::HTuple  autoTuple, empty, model_id, pose_in, pose_out, cov, hom, hom_new;
    m_regionTemp = new Halcon::Hobject();

    RelPose* pose_image = image->GetPose();
    RelPoseHTuple::GetPose(pose, &pose_in, pose_image->m_uniqueID);
    Halcon::pose_to_hom_mat3d(pose_in, &hom);
    Halcon::hom_mat3d_rotate_local(hom, M_PI, "y", &hom_new);
    Halcon::hom_mat3d_to_pose(hom_new, &pose_in);
    img = image->GetHImage();
    if(m_models.size() > 0)
    {
      SensorSpecificDeformModel& sensmodel = GetDeformShapeModel();
      if(!sensmodel.IsCompatible(cam))
      {
        printf( "DeformShape Model not valid for this sensor\n");
        return 0.0;
      }
      model_id = sensmodel.m_handle;
      Halcon::dilation_circle(*region,m_regionTemp, 30);
      Halcon::reduce_domain(*img, *m_regionTemp, &imgReduced);
      Halcon::find_planar_calib_deformable_model(imgReduced, model_id, -0.2,0.2,0.9,
                            1.1,0.9,1.1,0.5,1,1,0,0.9, empty, empty, &pose_out, &cov, &score);
      if(pose_out.Num() < 6)
      {
          Halcon::find_planar_calib_deformable_model(imgReduced, model_id, -0.2,0.2,0.9,
                                    1.1,1.0,1.0,0.05,1,1,0,0.1, empty, empty, &pose_out, &cov, &score);
          if(pose_out.Num() < 6)
          {
            printf( "DeformShape Model not valid for this sensor\n");
            return 0.0;
          }
      }
      /*Save the model ID*/
      m_models[cam->GetSensorID()].m_handle = model_id[0].I();
      m_models[cam->GetSensorID()].m_calib = sensmodel.m_calib;
      printf("Model valid for Sensor %s: %d (Number of valid sensors = %ld)\n", cam->GetSensorID().c_str(), model_id[0].I(), m_models.size());

    }
    else
    {
      /*reduce region of interest to a selected part of the image, that will be used for generating the model*/
      Halcon::erosion_circle(*region,m_regionTemp, 5);
      Halcon::reduce_domain(*img, *m_regionTemp, &imgReduced);
      /*temp varibale for constant auto*/
      autoTuple = "auto";
      /*Create the model*/
      Halcon::create_planar_calib_deformable_model(imgReduced, cam->m_calibration.CamParam(), pose_in, autoTuple,
          -0.8, 0.8, autoTuple, 0.8 , 1.2, autoTuple, 0.8,1.2,
          autoTuple,"point_reduction_low", "use_polarity", autoTuple,autoTuple, empty,empty,&model_id);
          printf("creating worked\n");
      /*Calculate the homography that is needed as starting value for tracking*/
      Halcon::find_planar_calib_deformable_model(imgReduced, model_id, -0.01,0.01,0.9,
                            1.1,1.0,1.0,0.8,1,1,0,0.9, empty, empty, &pose_out, &cov, &score);
      if(pose_out.Num() < 6)
      {
          Halcon::find_planar_calib_deformable_model(imgReduced, model_id, -0.01,0.01,0.9,
                                    1.1,1.0,1.0,0.05,1,1,0,0.1, empty, empty, &pose_out, &cov, &score);
          if(pose_out.Num() < 6)
          {
            XMLTag* tag = image->Save();
            std::string filename = tag->GetProperty(XML_ATTRIBUTE_FILENAME, "no image");
            printf("Saved failed image at: %s\n", filename.c_str());
            write_region(*m_regionTemp, HTuple(filename.c_str()) + ".reg");
            printf("Saved failed image at: %s\n", HTuple(HTuple(filename.c_str()) + ".reg")[0].S());
            delete tag;

            throw "DeformShape Model not valid";
          }
      }
      printf("Compare Pose_in with Pose_out:\n %f - %f = %f\n %f - %f = %f\n %f - %f = %f\n", pose_in[0].D(), pose_out[0].D(), pose_in[0].D() - pose_out[0].D(), pose_in[1].D() , pose_out[1].D(), pose_in[1].D() - pose_out[1].D(), pose_in[2].D(), pose_out[2].D(), pose_in[2].D() - pose_out[2].D());
      /*Save the model ID*/
      m_models[cam->GetSensorID()].m_handle = model_id[0].I();
      m_models[cam->GetSensorID()].m_calib = MinimalCalibration(cam->GetUnformatedCalibrationValues());
      printf("Created Model for Sensor %s: %d (Number of models = %ld)\n", cam->GetSensorID().c_str(), model_id[0].I(), m_models.size());
    }
  }
  catch(HException ex)
  {
     ROS_WARN("Error Learning Deform Shape Model: %s\n", ex.message);
     throw "Error Learning Deform Shape Model";
  }
  catch(const char* text)
  {
    printf("Error building deform shape: %s\n", text);
    return 0.0;
  }
  if(score.Num() > 0)
    return score[0].D();
  else
    return 0.0;
}


void DeformShapeModel::SaveTo(XMLTag* tag)
{
  Descriptor::SaveTo(tag);
  std::map<std::string, SensorSpecificDeformModel>::const_iterator iter = m_models.begin();
  for( ;iter != m_models.end(); iter++)
  {
      try
      {
        std::stringstream st;
        st << m_class->GetName() <<"_" << (*iter).first << ".dsm";
        std::string test  = st.str();
        size_t index = -1;
        while((index = test.find_first_of("/")) != test.npos)
        {
          test = test.replace(index, 1, "_");
        }
        m_filename = test;
        printf("write deform to %s\n", m_filename.c_str());
        if(!m_bWritten)
        {
          Halcon::write_deformable_model((*iter).second.m_handle, m_filename.c_str());
        }
        XMLTag* child = XMLTag::Tag(m_filename, XML_NODE_FILENAME);
        child->AddProperty(XML_PROPERTY_SENSORNAME, (*iter).first);
        tag->AddChild(child);
      }
      catch(Halcon::HException ex)
      {
        printf("DeformShapeModel::SaveTo: Error: %s  (filename: %s)\n", ex.message, m_filename.c_str());
      }
  }
  m_bWritten = true;
  tag->AddProperty(XML_ATTRIBUTE_AUTOGENERATED, (m_autoLearned ? "true" : "false"));
}

/*#endif*/ /*DEFORMSHAPE_AVAILABLE*/


