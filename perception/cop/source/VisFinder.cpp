/*
 * Copyright (C) 2009 by Ulrich Friedrich Klank <klank@in.tum.de>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

 
/************************************************************************
                        VisFinder.cpp - Copyright klank


**************************************************************************/

#include "VisFinder.h"
#include "XMLTag.h"
#include "ShapeModel.h"

#ifdef BOOST_THREAD
#include <boost/bind.hpp>
#include <boost/thread.hpp>
//#include <boost/placeholders.hpp>
#else
#endif
#ifdef HALCONIMG
#include "cpp/HalconCpp.h"
#include "cpp/HIOStream.h"
#include "cpp/HObjectModel3D.h"
#endif
#include <algorithm>

#ifdef BOOST_THREAD
#ifdef BOOST_1_35
#include <boost/thread/mutex.hpp>
#include "boost/date_time/posix_time/posix_time.hpp"
#include <iostream>
#else
#include <boost/thread/detail/lock.hpp>
typedef boost::detail::thread::lock_ops<boost::mutex> locker;
#endif
boost::mutex s_mutexDisplay;
#define BOOST(A) A
#else
#define BOOST (A) ;
#endif




///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 9.0
///////////////////////////////////////////////////////////////////////////////





#ifdef HALCONIMG
// Procedure declarations
// Chapter: Matching-3D
// Short Description: Display the axes of a 3d coordinate system
void disp_3d_coord_system (Halcon::HTuple WindowHandle, Halcon::HTuple CamParam,
Halcon::HTuple Pose, Halcon::HTuple CoordAxesLength);
// Chapter: Matching-3D
// Short Description: Generate a contour in form of an arrow
void gen_arrow_cont (Halcon::Hobject *Arrow, Halcon::HTuple Row1, Halcon::HTuple Column1,
    Halcon::HTuple Row2, Halcon::HTuple Column2);
    // Procedures
    // Chapter: Matching-3D
    // Short Description: Display the axes of a 3d coordinate system
void disp_3d_coord_system (Halcon::HTuple WindowHandle, Halcon::HTuple CamParam,
    Halcon::HTuple Pose, Halcon::HTuple CoordAxesLength)
{
    using namespace Halcon;

      // Local iconic variables
        Hobject  ContX, ContY, ContZ;


          // Local control variables
            HTuple  TransWorld2Cam, OrigCamX, OrigCamY, OrigCamZ;
              HTuple  Row0, Column0, X, Y, Z, RowAxX, ColumnAxX, RowAxY;
                HTuple  ColumnAxY, RowAxZ, ColumnAxZ;

    if ((Pose.Num())!=7)
    {
       return;
    }
     if (HTuple(Pose[5])==0.0)
    {
                  return;
    }
    pose_to_hom_mat3d(Pose, &TransWorld2Cam);
    //Project the world origin into the image
    affine_trans_point_3d(TransWorld2Cam, 0, 0, 0, &OrigCamX, &OrigCamY, &OrigCamZ);
    project_3d_point(OrigCamX, OrigCamY, OrigCamZ, CamParam, &Row0, &Column0);
                  //Project the coordinate axes into the image
    affine_trans_point_3d(TransWorld2Cam, CoordAxesLength, 0, 0, &X, &Y, &Z);
    project_3d_point(X, Y, Z, CamParam, &RowAxX, &ColumnAxX);
    affine_trans_point_3d(TransWorld2Cam, 0, CoordAxesLength, 0, &X, &Y, &Z);
    project_3d_point(X, Y, Z, CamParam, &RowAxY, &ColumnAxY);
    affine_trans_point_3d(TransWorld2Cam, 0, 0, CoordAxesLength, &X, &Y, &Z);
    project_3d_point(X, Y, Z, CamParam, &RowAxZ, &ColumnAxZ);
    gen_arrow_cont(&ContX, Row0, Column0, RowAxX, ColumnAxX);

    gen_arrow_cont(&ContY, Row0, Column0, RowAxY, ColumnAxY);
    gen_arrow_cont(&ContZ, Row0, Column0, RowAxZ, ColumnAxZ);
    disp_obj(ContX, WindowHandle);
    disp_obj(ContY, WindowHandle);
    disp_obj(ContZ, WindowHandle);
    set_tposition(WindowHandle, RowAxX+3, ColumnAxX+3);
    write_string(WindowHandle, "X");
    set_tposition(WindowHandle, RowAxY+3, ColumnAxY+3);
    write_string(WindowHandle, "Y");
    set_tposition(WindowHandle, RowAxZ+3, ColumnAxZ+3);
    write_string(WindowHandle, "Z");
    return;
}

// Chapter: Matching-3D
// Short Description: Generate a contour in form of an arrow
void gen_arrow_cont (Halcon::Hobject *Arrow, Halcon::HTuple Row1, Halcon::HTuple Column1,
Halcon::HTuple Row2, Halcon::HTuple Column2)
{
  using namespace Halcon;

  // Local iconic variables
  Hobject  Cross1, Cross2, CrossP1, CrossP2;


  // Local control variables
  HTuple  Length, Angle, MinArrowLength, DRow, DCol;
  HTuple  ArrowLength, Phi, P1R, P1C, P2R, P2C;

  //Generate a contour in form of a arrow
  Length = 7;
  Angle = 40;
  MinArrowLength = 2;
  DRow = Row2-Row1;
  DCol = Column2-Column1;
  ArrowLength = ((DRow*DRow)+(DCol*DCol)).Sqrt();
  if (ArrowLength<MinArrowLength)
  {
    Length = 0;
  }
  tuple_atan2(DRow, -DCol, &Phi);
  P1R = Row2-(Length*((Phi-(Angle.Rad())).Sin()));
  P1C = Column2+(Length*((Phi-(Angle.Rad())).Cos()));
  P2R = Row2-(Length*((Phi+(Angle.Rad())).Sin()));
  P2C = Column2+(Length*((Phi+(Angle.Rad())).Cos()));
  gen_cross_contour_xld(&Cross1, Row1, Column1, 6, 0.785398);
  gen_cross_contour_xld(&Cross2, Row2, Column2, 6, 0.785398);
  gen_cross_contour_xld(&CrossP1, P1R, P1C, 6, 0.785398);
  gen_cross_contour_xld(&CrossP2, P2R, P2C, 6, 0.785398);
  gen_contour_polygon_xld(&(*Arrow), (((Row1.Concat(Row2)).Concat(P1R)).Concat(Row2)).Concat(P2R),
  (((Column1.Concat(Column2)).Concat(P1C)).Concat(Column2)).Concat(P2C));
  return;
}


#endif /*HALCONIMG*/


// Constructors/Destructors
//

VisFinder::VisFinder ( XMLTag* configFile, ImageInputSystem& imageSystem, SignatureDB& db, AttentionManager& manager, VisLearner&	visLearner
#ifdef LOGFILE
                      ,LogFile& log) :
    m_selLocate(configFile != NULL ? configFile->GetChild(0) : NULL, log),
#else /*LOGFILE*/
     ) :
    m_selLocate(configFile != NULL ? configFile->GetChild(0) : NULL),
#endif /*LOGFILE*/
    m_imageSys(imageSystem),
    m_sigdb(db),
    m_visLearner(visLearner),
    m_attentionMan(manager)
{
    m_selLocate.SetName(XML_NODE_VISFINDER);
}

VisFinder::~VisFinder ( )
{
    for(std::map<int, TrackAlgorithm*>::iterator it = m_runningTracks.begin();
    it != m_runningTracks.end(); it++)
    {
        delete (*it).second;
    }
}





//
// Methods
//
/**
*	Saves the status of the Visual Finder
*/
XMLTag* VisFinder::Save()
{
    XMLTag* tag = new XMLTag(XML_NODE_VISFINDER);
    tag->AddChild(m_selLocate.Save());
    return tag;
}

/**
*	Manages an XML Query
*/
XMLTag* VisFinder::Query(std::string queryString)
{
    XMLTag* tagAll = m_sigdb.Query(queryString);
    if(tagAll == NULL)
        throw("Error in Query");
    for(unsigned int  i = 0; i < tagAll->CountChildren(); i++)
    {
        XMLTag* tag = tagAll->GetChild(i);
        if(tag->date() < XMLTag::OldTag())
        {
            return tag;
        }
        else
        {
            int type = tag->getQueryType();
            switch(type / 0x100)
            {
            case 0:
                {
                    Signature* sig = (Signature* )Elem::ElemFactory(tag);
                    int numofobjects = 0;
                    //tag.GetLocateInfo(pose, sig, numofobjects);
                    /*RelPose* retPose = */
                    Locate(*sig->m_relPose, *sig, numofobjects);
                    if(numofobjects == 0)
                        continue;
                    else
                    {
                        //return retPose->Save();
                        XMLTag* tag2 = sig->Save(true);
                        delete sig;
                        delete tagAll;
                        return tag2;
                    }
                }
            default:
                delete tagAll;
                return NULL;

            }
        }
    }
    delete tagAll;
    return NULL;
}

    /**
     * @return bool
     * @param  LastKnownPose
     * @param  Object
     * @param  numOfObjects
     */
    bool VisFinder::Detect(RelPose &lastKnownPose, Signature& object, int &numOfObjects)
    {
        return false;
    }

/**
     * @return RelPose
     * @param  LastKnownPose
     * @param  Object
     * @param  numOfObjects
     */
    RelPose* VisFinder::Locate (RelPose &lastKnownPose, Signature& object, int &numOfObjects)
    {
        std::vector<Camera*> cameras;
        unsigned int nCamera;
        RelPose* ret = 0;
        try
        {
            int offset = 0;
            while(true)
            {
                Camera* cam = m_imageSys.GetBestCamera(lastKnownPose, nCamera, offset);
                if(cam == NULL)
                    break;
                cameras.push_back(cam);
                offset++;
            }
            int locatertype = ALGORITHMTYPE_LOCATE;
            locatertype += numOfObjects > 1 ? ALGORITHMSPEC_ONETARGET : ALGORITHMSPEC_SEVERALTARGET;
            Algorithm<std::vector<RelPose*> >* alg = m_selLocate.BestAlgorithm(locatertype, object);
            if(alg != NULL)
            {
                double qualityMeasure = 0.0;
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
                BOOST(boost::system_time t0);
                BOOST(boost::system_time t1);
                BOOST(t0 = get_system_time());
#else
                boost::xtime t0, t1;
                boost::xtime_get(&t0, boost::TIME_UTC);
#endif
#endif

                std::vector<RelPose*> vec = alg->Perform(cameras, &lastKnownPose, object, numOfObjects, qualityMeasure);
                //TODO make more elements
                RelPose* r = vec.size() > 0 ? vec[0] : NULL;
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
                BOOST(t1 = get_system_time());
#ifdef _DEBUG
/*                std::cout << "RelPose ID " << r->m_uniqueID << "Calc time: "<< t1 - t0 <<std::endl;*/
#endif
#else
                boost::xtime_get(&t1, boost::TIME_UTC);
#ifdef _DEBUG
                printf("RelPose ID %d Calc time: %ds %d ms\n", r->m_uniqueID, t1.sec - t0.sec, (t1.nsec - t0.nsec) / 1000000);
#endif
#endif

#ifdef BOOST_1_35
                m_selLocate.EvalAlgorithm(alg, qualityMeasure, 10, &object);
#else
                m_selLocate.EvalAlgorithm(alg, qualityMeasure, (double)((1000000000 * (t1.sec - t0.sec))+(t1.nsec - t0.nsec)), &object);
#endif
#endif

                if(r != NULL && numOfObjects > 0)
                {
                    r->m_qualityMeasure = qualityMeasure;
                    object.SetPose(r);
                    if(qualityMeasure > 0.70)
                         m_visLearner.RefineObject (object);
                }
                if(numOfObjects > 0)
                {
                    //TODO
                }
                ret = (object.m_relPose);
            }
        }
        catch(char const* message)
        {
            printf("Error in Locate: %s\n", message);
        }
        return ret;
    }

    typedef struct
    {
       RelPose* pose;
       double quality;
       Camera* camera;
       Algorithm<std::vector<RelPose*> > * alg;
    } Results_t;

    bool comp_qual (const Results_t &t1, const Results_t &t2)
    {
      return t1.quality > t2.quality;
    }


#ifdef SWISS_RANGER_SERVICE

inline void normalize(double &a,double &b, double &c)
{
  double norm = sqrt(a*a + b*b + c*c);
  a /= norm;
  b /= norm;
  c /= norm;
}

inline double scalarproduct(const double &a,const double &b, const double &c, const double &d, const double &e, const double &f)
{
  return a * d + b* e + c*f;
}

inline void CrossProduct_l(const double b_x, const double b_y,const double b_z,const double c_x,const double c_y,const double c_z,double &a_x,double &a_y,double &a_z)
{
    a_x = b_y*c_z - b_z*c_y;
    a_y = b_z*c_x - b_x*c_z;
    a_z = b_x*c_y - b_y*c_x;
}

#include "ClusterDetector.h"
/*
float64 a
float64 b
float64 c
float64 d
robot_msgs/Point32 pcenter
robot_msgs/ObjectOnTable[] oclusters
*/
bool VisFinder::GetPlaneClusterCall(PossibleLocations_t *cluster_ids, RelPose* pose, Signature& sig)
{

  ClusterDetector* det = (ClusterDetector*)m_selLocate.BestAlgorithm(123, sig);
  if(det == NULL)
    return false;
  int num;
  double qual;
  std::vector<RelPose*>  results =  det->Inner(num, qual);
  for(size_t i = 0; i < results.size(); i++)
  {
    cluster_ids->push_back(std::pair<RelPose*, double>(results[i], qual));
  }
  return true;
}
#endif

void ShowSearchSpace(PossibleLocations_t* lastKnownPoses, Camera* cam)
{
  cam->Show();
  printf("Showing searchspaces\n");
  for(size_t i = 0; i < lastKnownPoses->size(); i++)
  {
#ifdef HALCONIMG
  try
  {
    Halcon::HTuple r,c;
    Halcon::HWindow* handle = cam->GetWindow();
    if( (*lastKnownPoses)[i].first->m_uniqueID == cam->m_relPose->m_uniqueID)
      continue;
    RelPose* pose = (*lastKnownPoses)[i].first;
    RelPose* posetmp = RelPoseFactory::GetRelPose(pose->m_uniqueID, cam->m_relPose->m_uniqueID);
    Matrix m = posetmp->GetMatrix();
    RelPoseFactory::FreeRelPose(posetmp);
    cout << m << endl;
    Halcon::project_3d_point(m.element(0, 3), m.element(1, 3), m.element(2, 3), cam->m_calibration.CamParam(), &r,&c);
    printf("%f %f %f\n", m.element(0, 3), m.element(1, 3), m.element(2, 3));
    printf("Position proj at : %f %f\n", r[0].D(), c[0].D());
    Halcon::Hobject circle1, circle2;
    Halcon::gen_circle(&circle1,r, c, 10);
    Halcon::gen_circle(&circle2,r, c, 20);
    Halcon::set_draw(handle->WindowHandle(), "margin");
    Halcon::set_color(handle->WindowHandle(), "yellow");
    Halcon::set_line_width(handle->WindowHandle(), 1);
    Halcon::disp_obj(circle1, handle->WindowHandle());
    Halcon::disp_obj(circle2, handle->WindowHandle());
   }
   catch(...)
   {
     printf("Display failed \n");
   }
#endif
  }
}


/**
     * @return RelPose
     * @param  LastKnownPose
     * @param  Object
     * @param  numOfObjects
     */
SignatureLocations_t VisFinder::Locate (PossibleLocations_t* lastKnownPoses, Signature& object, int &numOfObjects)
{
        std::vector<Camera*> cameras;
        unsigned int nCamera;
        double qualityMeasure = 0.0;
        Algorithm<std::vector<RelPose*> >* alg_fail = NULL;
        SignatureLocations_t ret;
        PossibleLocations_t::const_iterator it = lastKnownPoses->begin();
        std::vector<Results_t> all_matches;
        int maxObjToAdd = numOfObjects;
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
                  BOOST(boost::system_time t0);
                  BOOST(boost::system_time t1);
#else
                  boost::xtime t0, t1;
#endif
#endif
//#ifdef _DEBUG
#ifndef WIN32
#else
        static int s_i = 0;
        int i_cur = s_i++;
        printf("\nLOCK_DISPLAY s(%d)\n\n", i_cur);
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
        BOOST(s_mutexDisplay.lock());
#else
        BOOST(locker::lock(s_mutexDisplay));
#endif
#endif
#endif /* WIN32*/
//#endif
       int count_poses = 1;
#ifdef SWISS_RANGER_SERVICE
        if(lastKnownPoses->size() == 0)
        {
          Camera* cam = m_imageSys.GetCamara(0);
          if(cam != NULL)
              if(!GetPlaneClusterCall(lastKnownPoses, cam->m_relPose, object))
              {
                numOfObjects = 0;
                printf("No search position specified: 0 Results, no search\n");
              }
          printf("Got a new Searchspace\n");
          printf("lkp size %ld\n", lastKnownPoses->size());
          if(lastKnownPoses->size() > 0)
            printf("lastKnownPoses[0]: id %ld\n", (*lastKnownPoses)[0].first->m_uniqueID);
        }
#endif /*SWISS_RANGER_SERVICE*/
        it = lastKnownPoses->begin();
        for(;it != lastKnownPoses->end(); it++)
        {
            RelPose* lastKnownPose = (*it).first;
            if(lastKnownPoses == NULL)
            {
              printf("VisFinder: Errornous pose infromation\n");
               continue;
            }
            try
            {
                int offset = 0;
                printf("Get Best Camn \n");
                while(true)
                {
                    Camera* cam = m_imageSys.GetBestCamera(*lastKnownPose, nCamera, offset);
                    if(cam == NULL)
                        break;
                    cameras.push_back(cam);
                    offset++;
                }
                int locatertype = ALGORITHMTYPE_LOCATE;
                if(object.m_relPose == NULL)
                  object.SetPose(&lastKnownPose[0]);
//#ifdef _DEBUG
#ifndef WIN32
#ifdef BOOST_1_35
  BOOST(s_mutexDisplay.lock());
#else
  BOOST(locker::lock(s_mutexDisplay));
#endif

#endif /* WIN32*/
               if(count_poses == 1)
               {
                ShowSearchSpace(lastKnownPoses, cameras[0]);
                count_poses++;
                }


#ifndef WIN32
#ifdef BOOST_1_35
  BOOST(s_mutexDisplay.unlock());
#else
  BOOST(locker::unlock(s_mutexDisplay));
#endif

#endif /* WIN32*/
//#endif
                locatertype += numOfObjects > 1 ? ALGORITHMSPEC_SEVERALTARGET : ALGORITHMSPEC_ONETARGET ;
                Algorithm<std::vector<RelPose*> > * alg = m_selLocate.BestAlgorithm(locatertype, object);
                cameras[0]->NextFrame();
                if(alg != NULL)
                {
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
                   BOOST(t0 = boost::get_system_time());
#else
                   boost::xtime_get(&t0, boost::TIME_UTC);
#endif
#endif
#ifdef _DEBUG
                    printf("Pose ID before Perform: %ld\n", lastKnownPose->m_uniqueID);
#endif
                    int numOfObjects_tmp = numOfObjects;
                    std::vector<RelPose*> r = alg->Perform(cameras, lastKnownPose, object, numOfObjects_tmp, qualityMeasure);
                    alg_fail = alg;
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
                    BOOST(t1 = get_system_time());
                    BOOST(boost::posix_time::time_duration td = t1 - t0);
                    BOOST(printf("Calc time: %s\n", boost::posix_time::to_simple_string(td).c_str()));

#ifdef _DEBUG
/*                    std::cout << "Calc time: " << t1- t0 << std::endl;*/
#endif
#else
                    boost::xtime_get(&t1, boost::TIME_UTC);
                    printf("Calc time: %ds %dms\n", t1.sec - t0.sec, (t1.nsec - t0.nsec) / 1000000);
#endif
#endif
/*#ifdef _DEBUG*/
                  /**TODO: remove : ugly HACK */
                  try
                  {
                    ShapeModel* sm = (ShapeModel*)(object.GetElement(0, DESCRIPTOR_SHAPE ));
                    if(sm != NULL)
                      sm->ShowRegion(cameras[0]);
#ifdef HALCONIMG
                    Halcon::HTuple pose2;
                    lastKnownPose->GetPose(&pose2, -1);
                    disp_3d_coord_system (cameras[0]->GetWindow()->WindowHandle(), cameras[0]->m_calibration.CamParam(), pose2, 0.3);
#endif /*HALCONIMG*/
                  }
                  catch(...)
                  {
                    printf("VisFinder: Display of region failed! TODO remove\n");
                  }
                  /**TODO remove until here*/
/*#endif*/
                  for(std::vector<RelPose*>::const_iterator it_poses = r.begin(); it_poses != r.end(); it_poses++)
                  {
                    Results_t res_tmp;
                    res_tmp.pose = *it_poses;
                    res_tmp.quality = qualityMeasure;
                    res_tmp.camera = cameras[0];
                    res_tmp.alg = alg;
                    all_matches.push_back(res_tmp);
                  }
                }
                else
                {
                  printf("No algorithm found for the quieried Problem\n");
                }
            }
            catch(char const* message)
            {
                printf("Error in Locate: %s\n", message);

            }
        }
        std::sort(all_matches.begin(), all_matches.end(), comp_qual);
        if(all_matches.size() > 0 && numOfObjects > 0)
        {
#ifdef _DEBUG
                      /*#ifdef BOOST_1_35
  BOOST(s_mutexDisplay.lock());
#else
  BOOST(locker::lock(s_mutexDisplay));
#endif

                      cameras[0]->Show();
#ifdef BOOST_1_35
  BOOST(s_mutexDisplay.unlock());
#else
  BOOST(locker::unlock(s_mutexDisplay));
#endif
*/
#endif
          for(unsigned int i = 0; i < all_matches.size(); i++)
          {
            RelPose* pose = all_matches[i].pose;
            if(i == 0)
            {
              object.SetPose(pose);
//#ifdef _DEBUG
#ifndef WIN32
#ifdef BOOST_1_35
              BOOST(s_mutexDisplay.lock());
#else
              BOOST(locker::lock(s_mutexDisplay));
#endif

#endif
              try
              {
                object.Show(all_matches[i].camera);
              }
              catch(char* error)
              {
                printf("Error in Display: %s\n", error);
              }
#ifndef WIN32
#ifdef BOOST_1_35
              BOOST(s_mutexDisplay.unlock());
#else
              BOOST(locker::unlock(s_mutexDisplay));
#endif

#endif
//#endif
              pose->m_qualityMeasure = all_matches[i].quality;
              ret.push_back(std::pair<RelPose*, Signature*>(pose, &object));
              if(pose->m_qualityMeasure > 0.70)
                 m_visLearner.RefineObject (object);
#ifdef BOOST_THREAD
              m_sigdb.AddSignatureThreaded(&object);
#else
              m_sigdb.AddSignature(&object);
#endif
              numOfObjects = 1;
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
              m_selLocate.EvalAlgorithm(all_matches[i].alg, pose->m_qualityMeasure, 10/*(double)(t1 - t0)*/, &object);
#else
              m_selLocate.EvalAlgorithm(all_matches[i].alg, pose->m_qualityMeasure, (double)((1000000000 * (t1.sec - t0.sec))+(t1.nsec - t0.nsec)), &object);
#endif
#endif
            }
            else
            {
              if(numOfObjects >= maxObjToAdd)
              {
                break;
              }
              Signature* sig = (Signature*)(object.Duplicate(false));
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
              m_selLocate.EvalAlgorithm(all_matches[i].alg, pose->m_qualityMeasure, 10/*(double)(t1 - t0)*/, &object);
#else
              //m_selLocate.EvalAlgorithm(all_matches[i].alg, pose->m_qualityMeasure, (double)((1000000000 * (t1.sec - t0.sec))+(t1.nsec - t0.nsec)), sig);
#endif
#endif
              sig->SetPose(pose);
//#ifdef _DEBUG
#ifndef WIN32
#ifdef BOOST_1_35
              BOOST(s_mutexDisplay.lock());
#else
              BOOST(locker::lock(s_mutexDisplay));
#endif

#endif
              try
              {
                sig->Show(all_matches[i].camera);
              }
              catch(char* error)
              {
                printf("Error in Display: %s\n", error);
              }
#ifndef WIN32
#ifdef BOOST_1_35
              BOOST(s_mutexDisplay.unlock());
#else
              BOOST(locker::unlock(s_mutexDisplay));
#endif

#endif
//#endif
              /*pose->m_qualityMeasure = qualityMeasure;*/
              ret.push_back(std::pair<RelPose*, Signature*>(pose, sig));
#ifdef BOOST_THREAD
              m_sigdb.AddSignatureThreaded(sig);
#else
              m_sigdb.AddSignature(sig);
#endif
              numOfObjects++;
              /*if(qualityMeasure > 0.70)
                 m_visLearner.RefineObject(sig);*/
            }
          }
        }
        else
        {
#ifdef BOOST_THREAD
#ifdef BOOST_1_35
            m_selLocate.EvalAlgorithm(alg_fail, qualityMeasure, 10/*(double)(t1 - t0)*/, &object);
#else
            //m_selLocate.EvalAlgorithm(alg_fail, qualityMeasure, (double)((1000000000 * (t1.sec - t0.sec))+(t1.nsec - t0.nsec)), &object);
#endif
#endif
#ifdef BOOST_THREAD
           m_sigdb.AddSignatureThreaded(&object);
#else
           m_sigdb.AddSignature(&object);
#endif
            /*
#ifdef _DEBUG
#ifdef BOOST_1_35
  BOOST(s_mutexDisplay.lock());
#else
  BOOST(locker::lock(s_mutexDisplay));
#endif
           object.Show(cameras[0]);
#ifdef BOOST_1_35
  BOOST(s_mutexDisplay.unlock());
#else
  BOOST(locker::unlock(s_mutexDisplay));
#endif

#endif*/
       }
#ifdef HALCONIMG
  if(cameras.size() > 0 && cameras[0] != NULL)
   Halcon::dump_window(cameras[0]->GetWindow()->WindowHandle(), "png", "sceenshot.png");
#endif
//#ifdef _DEBUG
#ifdef BOOST_THREAD
#ifndef WIN32
#else
#ifdef BOOST_1_35
  BOOST(s_mutexDisplay.unlock());
#else
  BOOST(locker::unlock(s_mutexDisplay));
#endif

        printf("\nUNLOCK_DISPLAY s(%d)\n\n", i_cur);
#endif /*Win32*/
#endif
//#endif
        return ret;
}


    /**
     * @param  Object
     */
    void VisFinder::StartTrack  ( Signature& object, RelPose* poseEstimation)
    {
        try
        {
            int locatertype = ALGORITHMTYPE_TRACK;
            locatertype = ALGORITHMSPEC_SEVERALTARGET; /** TODO: Check how to include Locating and special Tracking algorithms*/
            Algorithm<std::vector<RelPose*> > * alg = m_selLocate.BestAlgorithm(locatertype, object);
            if(alg != NULL)
            {
              if(poseEstimation != NULL)
                object.SetPose(poseEstimation);
              TrackAlgorithm*  tracking = new TrackAlgorithm(object, alg, m_imageSys);
              m_runningTracks[object.m_ID] = tracking;
            }
            else
            {
              printf("No Algorithm for Tracking of object %d found\n", object.m_ID);
            }
        }
        catch(...)
        {
        }
        return;
    }

    /**
     * @param  Object
     */
    void VisFinder::StopTrack (Signature& object)
    {
        std::map<int, TrackAlgorithm*>::iterator it = m_runningTracks.find(object.m_ID);
        if(it != m_runningTracks.end())
        {
            delete (*it).second;
            m_runningTracks.erase(it);
        }

    }

  /**
   * @return RelPose
   * @param  CurImage
   * @param  Pose
   * @param  Obj1
   * @param  Obj2
   */
    RelPose* VisFinder::RelTwoObjects (const RelPose &Pose, Signature& Obj1, Signature& Obj2 )
    {
        return NULL;
    }


  /**
   * @param  world
   */
    void VisFinder::UpdateWorldStatus (Signature &world )
    {
    }

  /**
   * @return double
   * @param  DistractionPoints
   * @param  RoIs
   * @param  DisctionLevels
   */
    double VisFinder::GetDistractionPoints (std::vector<RelPose*> &DistractionPoints, std::vector<double> &RoIs, std::vector<double> &DisctionLevels ) const
    {
        return 0.0;
    }

/**
*	AddAlgorithm
*	@param alg
*/
    void VisFinder::AddAlgorithm(Algorithm<std::vector<RelPose*> >* alg)
{
    m_selLocate.AddAlgorithm(alg, ALGORITHMSPEC_ONETARGET, 1.0, 0.0);
}

#ifndef WIN32
#include "AlgorithmSelector.hpp"
template class AlgorithmSelector<std::vector<RelPose*> >;;
#else
#include "AlgorithmSelector.hpp"
template AlgorithmSelector<std::vector<RelPose*> >;
#endif

